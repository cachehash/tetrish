#!/bin/bash

UP=$'\E[A'
DOWN=$'\E[B'
LEFT=$'\E[D'
RIGHT=$'\E[C'
BIT='[]'
BIT=$'\E[7m[]'
BOT='--'
VOID='  '
W=10
H=24
CLEAR=$'\E[0m'
GRID=()
ORANGE=$'\E[31m'
RED=$'\E[31m'
GREEN=$'\E[32m'
YELLOW=$'\E[33m'
BLUE=$'\E[34m'
MAGENTA=$'\E[35m'
CYAN=$'\E[36m'
COLORS=( "$RED" "$GREEN" "$BLUE" "$CYAN" "$YELLOW" "$MAGENTA" )
tetronis=( I J L O S T Z )
tetroni_I=(
	''	''	''	''
	"$CYAN"	"$CYAN"	"$CYAN"	"$CYAN"
	''	''	''	''
	''	''	''	''
)
tetroni_J=(
	''	''	''	''
	"$BLUE" ''	''	''
	"$BLUE"	"$BLUE"	"$BLUE"	''
	''	''	''	''
) 
tetroni_L=(
	''		''		''		''
	''		''		"$ORANGE"	''
	"$ORANGE"	"$ORANGE"	"$ORANGE"	''
	''		''		''		''
) 
tetroni_O=(
	''	''		''		''
	''	"$YELLOW"	"$YELLOW"	''
	''	"$YELLOW"	"$YELLOW"	''
	''	''		''		''
)
tetroni_S=(
	''		''		''		''
	''		"$GREEN"	"$GREEN"	''
	"$GREEN"	"$GREEN"	''		''
	''		''		''		''
)
tetroni_T=(
	''		''		''		''
	''		"$MAGENTA"	''		''
	"$MAGENTA"	"$MAGENTA"	"$MAGENTA"	''
	''		''		''		''
)
tetroni_Z=(
	''	''	''	''
	"$RED"	"$RED"	''	''
	''	"$RED"	"$RED"	''
	''	''	''	''
)
copyTetroni() {
	local x=${1:0:1}
	eval 'tetroni=("${tetroni_'"$x"'[@]}")'
}
newTetroni() {
	local n=${#tetronis[@]}
	copyTetroni "$next"
	next=${tetronis[RANDOM%n]}
	Tx=$((W/2-2))
	Ty=-1
	if ! inBounds ;then
		display
		echo 'game over'
		exit
	fi
}

render() {
	local x y v line dx dy p
	w=`tput cols`
	h=`tput lines`
	start=$(((w-W*${#BOT})/2))
	lines=()
	for ((y=0; y < H; y++)) ; do
		line='|'
		for ((x=0; x < W; x++)) ; do
			v=${GRID[x+y*W]}
			dx=$((x-Tx))
			dy=$((y-Ty))
			if ((0 <= dx && dx < 4 && 0 <= dy && dy < 4)) && [[ "${tetroni[dy*4+dx]}" != "" ]] ; then
				v=$'\E[1m'${tetroni[dx+dy*4]}
				p=$BIT
			else
				if [[ "$v" == "" ]] ; then
					p=$VOID
				else
					p=$BIT
				fi
			fi
			line+=$v$p$CLEAR
		done
		line+='|'
		if ((y < 4)) ; then
			for ((x=0; x < 4; x++)) ; do
				eval 'v=${tetroni_'"$next"'[x+y*4]}'
				if [[ "$v" == "" ]] ; then
					p=$VOID
				else
					p=$BIT
				fi
				line+=$'\E[1m'$v$p$CLEAR
			done
		fi
		lines+=("$line")
	done
	line='\'
	for ((x = 0; x < W; x++)) ;do
		line+=$BOT
	done
	lines+=("$line"/)
}
draw() {
	local showed=0
	for l in "${lines[@]}" ; do
		if [[ "$showed" == 0 ]] ; then
			printf %"$start"d "$score"00
			showed=1
		else
			printf %"$start"s ''
		fi
		printf '%s\n' "$l"
	done
}
display() {
	render
	for ((i = 0; i <= H; i++)) ; do
		printf %s $'\E[A'
	done
	draw
}
fall() {
	if ! slide 0 1 ; then
		land
	fi
}
land() {
	local dy dx
	dx=$((x-Tx))
	dy=$((y-Ty))
	for ((dx=0; dx < 4; dx++)) ; do
		for ((dy=0; dy < 4; dy++)) ; do
			x=$((dx+Tx))
			y=$((dy+Ty))
			v=${tetroni[dx+dy*4]}
			if [[ "$v" != '' ]] ; then
				GRID[x+y*W]=$v
			fi
		done
	done
	newTetroni
	checkMatch
}
checkMatch() {
	local x y dy dx matches
	dy=$((H-1))
	for ((y=H-1; y >= 0; y--)) ; do
		rowMatch=1
		for ((x=0; x < W; x++)) ; do
			if ((y != dy)) ; then
				GRID[x+dy*W]="${GRID[x+y*W]}"
				GRID[x+y*W]=''
			fi
			if [[ "${GRID[x+dy*W]}" == '' ]] ; then
				rowMatch=0
			fi
		done
		if ((rowMatch != 1)) ; then
			let dy--
		else
			let matches++
		fi
	done
	if (( matches != 0 )) ; then
		(( score += 2**(matches-1) ))
	fi
}
inBounds() {
	local dy dx
	dx=$((x-Tx))
	dy=$((y-Ty))
	for ((dx=0; dx < 4; dx++)) ; do
		for ((dy=0; dy < 4; dy++)) ; do
			x=$((dx+Tx))
			y=$((dy+Ty))
			v=${tetroni[dx+dy*4]}
			if [[ "$v" != '' ]] ; then
				if ((x < 0 || x >= W || y < 0 || y >= H)) || [[ "${GRID[x+y*W]}" != '' ]] ; then
					return 1
				fi
			fi
		done
	done
	return 0
}
slide() {
	local dx=$1
	local dy=$2
	let Tx+=dx
	let Ty+=dy
	if ! inBounds ; then
		let Tx-=dx
		let Ty-=dy
		return 1
	fi
	return 0
}
bringDown() {
	while slide 0 1 ; do
		:
	done
}
rotate() {
	forceRotate 1
	if ! inBounds ; then
		forceRotate
	fi
}
forceRotate() {
	local csz=4
	local s=$((csz-1))
	local half=$(((csz+1)/2))
	local hsz=$((csz/2))
	local x y i pval val ox oy
	for ((x = 0; x < half; x++)) ; do
		for ((y = 0; y < hsz; y++)) ; do
			val=${tetroni[x+y*4]}
			for ((i = 0; i < 4; i++)) ; do
				if (($# >= 1)) ; then
					oy=$y
					y=$x
					x=$((s-oy))
				else
					ox=$x
					x=$y
					y=$((s-ox))
				fi
				pval=${tetroni[x+y*4]}
				tetroni[x+y*4]=$val
				val=$pval
			done
		done
	done
}
#RANDOM=1
#for ((y=0; y < H; y++)) ; do
#	for ((x=0; x < W; x++)) ; do
#		GRID[x+y*W]=${COLORS[RANDOM%${#COLORS[@]}]}
#		sleep .5
#		display
#	done
#done
newTetroni
newTetroni
render
draw
IFS=
(
	while sleep .5 ; do
		printf j
	done &
	while read -rsN1 p; do 
		if [[ "$p" == $'\E' ]] ; then
			read -rsN2 ap
			p+=$ap
		fi
		case "$p" in
		h|"$LEFT")
			printf h
		;;
		j|"$DOWN")
			printf j
		;;
		k|"$UP")
			printf k
		;;
		l|$RIGHT)
			printf l
		;;
		' ')
			printf G
		;;
		esac
	done 
) | while read -rsN1 p; do
	case "$p" in
	h)
		slide -1 0
	;;
	j)
		fall
	;;
	k)
		rotate
	;;
	l)
		slide 1 0
	;;
	G)
		bringDown
	;;

	esac
	display
done
