#!/bin/bash
#disable all the posix features that make unquoted vars dangerous
set -f
IFS=

MAX_FRAMESKIP=3
#if it takes this long or less to read input, assume it's
#coming from the buffer and we need to frame
#skip to catch up
MAX_BUFF_WAIT=10

UP=$'\E[A'
DOWN=$'\E[B'
LEFT=$'\E[D'
RIGHT=$'\E[C'

C_UP=$'\EOA'
C_DOWN=$'\EOB'
C_LEFT=$'\EOD'
C_RIGHT=$'\EOC'

LIGHT=$'\E[1m'
DARK=$'\E[2m'
CLEAR=$'\E[0m'

VOID='  '
BIT='ðŸ”³'
BOT='â”€â”€'
_J='â”˜'
L_='â””'

#BIT='[]'
#BOT='--'
#_J=/
#L_=\\

FALLING=
PREVIEW=$FALLING
LANDED=
GHOST=$LIGHT

W=10
H=24
T_SZ=4
paused=0

join() {
	echo "$1" | sed -e 's%m\E\[%;%'
}
read_ch() {
	local IFS
	unset IFS
	if [ -t 0 ] ; then
		local read_ch_old=`stty -g`
		stty -icanon -echo
		eval "$1"'=$(dd bs=1 count=1 2>/dev/null)'
		stty $read_ch_old
	else
		eval "$1"'=$(dd bs=1 count=1 2>/dev/null)'
	fi
}

COLOR_PREFIX=$'\E[7m'
ORANGE=`join $COLOR_PREFIX$'\E[33m'`
RED=`join $LIGHT$COLOR_PREFIX$'\E[31m'`
GREEN=`join $LIGHT$COLOR_PREFIX$'\E[32m'`
YELLOW=`join $LIGHT$COLOR_PREFIX$'\E[33m'`
BLUE=`join $LIGHT$COLOR_PREFIX$'\E[34m'`
MAGENTA=`join $LIGHT$COLOR_PREFIX$'\E[35m'`
CYAN=`join $LIGHT$COLOR_PREFIX$'\E[36m'`

COLORS=( "$RED" "$GREEN" "$BLUE" "$CYAN" "$YELLOW" "$MAGENTA" )

tetroni() {
	local x y z
	z=2
	for ((x = 0; x < 4; x++)) ; do
		for ((y = 0; y < 4; y++)) ; do
			eval 'tetroni_'$1_${x}_$y'=$'$z
			let z++
		done
	done
}
tetronis=( I J L O S T Z )
tetroni_I=(
	''	''	''	''
	"$CYAN"	"$CYAN"	"$CYAN"	"$CYAN"
	''	''	''	''
	''	''	''	''
)
tetroni_J=(
	''	''	''	''
	"$BLUE" ''	''	''
	"$BLUE"	"$BLUE"	"$BLUE"	''
	''	''	''	''
) 
tetroni_L=(
	''		''		''		''
	''		''		"$ORANGE"	''
	"$ORANGE"	"$ORANGE"	"$ORANGE"	''
	''		''		''		''
) 
tetroni_O=(
	''	''		''		''
	''	"$YELLOW"	"$YELLOW"	''
	''	"$YELLOW"	"$YELLOW"	''
	''	''		''		''
)
tetroni_S=(
	''		''		''		''
	''		"$GREEN"	"$GREEN"	''
	"$GREEN"	"$GREEN"	''		''
	''		''		''		''
)
tetroni_T=(
	''		''		''		''
	''		"$MAGENTA"	''		''
	"$MAGENTA"	"$MAGENTA"	"$MAGENTA"	''
	''		''		''		''
)
tetroni_Z=(
	''	''	''	''
	"$RED"	"$RED"	''	''
	''	"$RED"	"$RED"	''
	''	''	''	''
)
copyTetroni() {
	local x=${1:0:1}
	eval 'tetroni=("${tetroni_'"$x"'[@]}")'
}
newTetroni() {
	local n=${#tetronis[@]}
	copyTetroni "$next"
	next=${tetronis[RANDOM%n]}
	Tx=$((W/2-2))
	Ty=-1
	if ! inBounds ;then
		display
		echo 'game over'
		exit
	fi
}

render() {
	local x y v line dx dy p bdy By
	y=$Ty
	bringDown
	By=$Ty
	Ty=$y

	w=`tput cols`
	h=`tput lines`
	start=$(((w-W*${#BOT})/2))
	lines=()
	for ((y=0; y < H; y++)) ; do
		line='â”‚'
		for ((x=0; x < W; x++)) ; do
			eval 'v=$GRID_'${x}_$y
			dx=$((x-Tx))
			dy=$((y-Ty))
			bdy=$((y-By))
			if ((0 <= dx && dx < T_SZ && 0 <= dy && dy < T_SZ)) && [[ "${tetroni[dy*T_SZ+dx]}" != "" ]] ; then
				v=$FALLING${tetroni[dx+dy*T_SZ]}
				p=$BIT
			elif ((0 <= dx && dx < T_SZ && 0 <= bdy && bdy < T_SZ)) && [[ "${tetroni[bdy*T_SZ+dx]}" != "" ]] ; then
				v=$GHOST
				p=$BIT
			else
				if [[ "$v" == "" ]] ; then
					p=$VOID
				else
					p=$BIT
				fi
			fi
			if ((paused == 1 )) ; then
				v=
			fi
			line+=$v$p$CLEAR
		done
		line+='â”‚'
		if ((y < T_SZ)) ; then
			for ((x=0; x < T_SZ; x++)) ; do
				eval 'v=${tetroni_'"$next"'[x+y*T_SZ]}'
				if [[ "$v" == "" ]] ; then
					p=$VOID
				else
					p=$BIT
				fi
				if ((paused == 1 )) ; then
					v=
				fi
				line+=$PREVIEW$v$p$CLEAR
			done
		fi
		lines+=("$line")
	done
	line=$L_
	for ((x = 0; x < W; x++)) ;do
		line+=$BOT
	done
	lines+=("$line$_J")
}
draw() {
	local showed=0
	for l in "${lines[@]}" ; do
		if [[ "$showed" == 0 ]] ; then
			printf %"$start"d "$score"00
			showed=1
		else
			printf %"$start"s ''
		fi
		printf '%s\n' "$l"
	done
}
display() {
	render
	tput cuu $((H+1))
	draw
}
fall() {
	if ! slide 0 1 ; then
		land
	fi
}
land() {
	local dy dx
	dx=$((x-Tx))
	dy=$((y-Ty))
	for ((dx=0; dx < T_SZ; dx++)) ; do
		for ((dy=0; dy < T_SZ; dy++)) ; do
			x=$((dx+Tx))
			y=$((dy+Ty))
			v=${tetroni[dx+dy*T_SZ]}
			if [[ "$v" != '' ]] ; then
				#GRID[x+y*W]=$v
				eval "GRID_${x}_$y="'$v'
			fi
		done
	done
	newTetroni
	checkMatch
}
checkMatch() {
	local x y dy dx matches
	dy=$((H-1))
	for ((y=H-1; y >= 0; y--)) ; do
		rowMatch=1
		for ((x=0; x < W; x++)) ; do
			if ((y != dy)) ; then
				#GRID[x+dy*W]="${GRID[x+y*W]}"
				eval "GRID_${x}_$dy="'$GRID_'"${x}_$y"
				#GRID[x+y*W]=''
				eval "GRID_${x}_$y="
			fi
			#if [[ "${GRID[x+dy*W]}" == '' ]] ; then
			if eval '[[ "$GRID_'${x}_$dy'" == "" ]]' ; then
				rowMatch=0
			fi
		done
		if ((rowMatch != 1)) ; then
			let dy--
		else
			let matches++
		fi
	done
	if (( matches != 0 )) ; then
		(( score += 2**(matches-1) ))
	fi
}
inBounds() {
	local dy dx x y v
	dx=$((x-Tx))
	dy=$((y-Ty))
	for ((dx=0; dx < T_SZ; dx++)) ; do
		for ((dy=0; dy < T_SZ; dy++)) ; do
			x=$((dx+Tx))
			y=$((dy+Ty))
			v=${tetroni[dx+dy*T_SZ]}
			if [[ "$v" != '' ]] ; then
				if ((x < 0 || x >= W || y < 0 || y >= H)) || eval '[[ "$GRID_'${x}_$y'" != "" ]]' ; then
					return 1
				fi
			fi
		done
	done
	return 0
}
slide() {
	local dx=$1
	local dy=$2
	let Tx+=dx
	let Ty+=dy
	if ! inBounds ; then
		let Tx-=dx
		let Ty-=dy
		return 1
	fi
	return 0
}
bringDown() {
	while slide 0 1 ; do
		:
	done
}
rotate() {
	forceRotate $1
	if ! inBounds ; then
		forceRotate $((0-$1))
	fi
}
forceRotate() {
	local csz=$T_SZ
	local s=$((csz-1))
	local half=$(((csz+1)/2))
	local hsz=$((csz/2))
	local x y i pval val ox oy
	for ((x = 0; x < half; x++)) ; do
		for ((y = 0; y < hsz; y++)) ; do
			val=${tetroni[x+y*T_SZ]}
			for ((i = 0; i < 4; i++)) ; do
				if (($1 >= 1)) ; then
					oy=$y
					y=$x
					x=$((s-oy))
				else
					ox=$x
					x=$y
					y=$((s-ox))
				fi
				pval=${tetroni[x+y*T_SZ]}
				tetroni[x+y*T_SZ]=$val
				val=$pval
			done
		done
	done
}
togglePause() {
	local obit
	if ((paused == 0)) ; then
		paused=1
		obit=$BIT
		BIT=$VOID
		display
		BIT=$obit
	else
		paused=0
		display
	fi
}
newTetroni
newTetroni
render
draw
IFS=
(
	while sleep .5 ; do
		printf j
		#printf $'\a' >&2
	done &
	while read_ch p; do 
		if [[ "$p" == $'\E' ]] ; then
			read_ch ap
			p+=$ap
			read_ch ap
			p+=$ap
		fi
		case "$p" in
		h|"$LEFT")
			printf h
		;;
		j|"$DOWN")
			printf j
		;;
		k|"$UP"|"$C_RIGHT")
			printf k
		;;
		r|"$C_UP"|"$C_LEFT")
			printf r
		;;
		l|$RIGHT)
			printf l
		;;
		' '|"$C_DOWN")
			printf G
		;;
		p)
			printf p
		;;
		esac
	done 
) | while read_ch p; do
	#assume that if the delay was less than 100 ms we
	#read input from buffer and therefore need to 
	#frameskip
	if ((`date +%s%3N` - date < MIN_BUFF_WAIT)) ; then
		skip=1
	else
		skip=0
	fi
	if ((paused == 1)) ; then
		if [[ "$p" == p ]] ; then
			togglePause
		fi
	else
		case "$p" in
		h)
			slide -1 0
		;;
		j)
			fall
		;;
		k)
			rotate 1
		;;
		l)
			slide 1 0
		;;
		G)
			bringDown
		;;
		r)
			rotate -1
		;;
		p)
			togglePause
		;;
		esac
	fi
	if (( skip == 1 && fs < MAX_FRAMESKIP )) ; then
		let fs++
	else
		if ((paused == 0)) ; then
			display
		fi
		fs=0
	fi
	date=`date +%s%3N`
done
