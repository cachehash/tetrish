#!/bin/bash
#disable all the posix features that make unquoted vars dangerous
set -f
IFS=
if [ ! -z "$ZSH_VERSION" ] ; then
	setopt sh_word_split
	#for some reason zsh was using a static seed for the randomness
	unset RANDOM
	#RANDOM=`shuf -i 0-10000 -n 1`
fi
ascii=1
for a in "$@"; do
	case "$a" in
	-A)
		ascii=1
	;;
	-a)
		ascii=0
	;;
	esac
done

ENDL='
'
MAX_FRAMESKIP=3
#if it takes this long or less to read input, assume it's
#coming from the buffer and we need to frame
#skip to catch up
MAX_BUFF_WAIT=10

UP='[A'
DOWN='[B'
LEFT='[D'
RIGHT='[C'

C_UP='OA'
C_DOWN='OB'
C_LEFT='OD'
C_RIGHT='OC'

LIGHT='[1m'
DARK='[2m'
CLEAR='[0m'

VOID='  '
if [ "$ascii" -eq 0 ] ; then
	BIT='ðŸ”³'
	BOT='â”€â”€'
	_J='â”˜'
	L_='â””'
	WALL='â”‚'
	CW=2
else 
	BIT='[]'
	BOT='--'
	_J=/
	L_=\\
	WALL='|'
	CW=2
fi

FALLING=
PREVIEW=$FALLING
LANDED=
GHOST=$LIGHT

W=10
H=24
T_SZ=4
paused=0

if [ ! -z "$BASH_VERSION" ] ; then
	read_ch() {
		read -rsN1 "$1"
	}
else
	read_ch() {
		IFS_PREV=$IFS
		IFS=' 
		 '
		if [ -t 0 ] ; then
			read_ch_old=`stty -g`
			stty -icanon -echo
			eval "$1"'=`dd bs=1 count=1 2>/dev/null`'
			stty $read_ch_old
		else
			eval "$1"'=`dd bs=1 count=1 2>/dev/null`'
		fi
		IFS=$IFS_PREV
	}
fi

COLOR_PREFIX='[7m'
ORANGE=$COLOR_PREFIX'[33m'
RED=$LIGHT$COLOR_PREFIX'[31m'
GREEN=$LIGHT$COLOR_PREFIX'[32m'
YELLOW=$LIGHT$COLOR_PREFIX'[33m'
BLUE=$LIGHT$COLOR_PREFIX'[34m'
MAGENTA=$LIGHT$COLOR_PREFIX'[35m'
CYAN=$LIGHT$COLOR_PREFIX'[36m'

numTetronis=7
numTetronisM1=6

#check if shell suports $RANDOM
if [ 8$RANDOM -ne 8 ] ; then
	getRandom() {
		echo $(($RANDOM % $numTetronis ))
	}
else
	getRandom() {
		shuf -i 0-$numTetronisM1 -n 1
	}
fi
sleep() {
	/bin/sleep "$1"
}
getRandTetroni() {
	case `getRandom` in
	0)
		echo I
	;;
	1)
		echo J
	;;
	2)
		echo L
	;;
	3)
		echo O
	;;
	4)
		echo S
	;;
	5)
		echo T
	;;
	6)
		echo Z
	;;
	esac
}
getColor() {
	case "$1" in
	O)
		echo "$ORANGE"
	;;
	R)
		echo "$RED"
	;;
	G)
		echo "$GREEN"
	;;
	Y)
		echo "$YELLOW"
	;;
	B)
		echo "$BLUE"
	;;
	M)
		echo "$MAGENTA"
	;;
	C)
		echo "$CYAN"
	;;
	esac
}
tetroni() {
	IFS_PREV=$IFS
	IFS='
	 '
	z=0
	for c in $2 ; do
		x=`expr $z % $T_SZ`
		y=`expr $z / $T_SZ`
		c=`getColor $c`
		eval 'tetroni_'$1_${x}_$y'=$c'
		z=`expr $z + 1`
	done
	IFS=$IFS_PREV
}
tetroni I '
	. C . .
	. C . .
	. C . .
	. C . .
	'
tetroni J '
	. B B .
	. B . .
	. B . .
	. . . .
	'
tetroni L '
	. O O .
	. . O .
	. . O .
	. . . .
	'
tetroni O '
	. . . .
	. Y Y .
	. Y Y .
	. . . .
	'
tetroni S '
	. . . .
	. G G .
	G G . .
	. . . .
	'
tetroni T '
	. . . .
	. M . .
	M M M .
	. . . .
	'
tetroni Z '
	. . . .
	R R . .
	. R R .
	. . . .
	'
copyTetroni() {
	cp_x=0
	while [ "$cp_x" -lt "$T_SZ" ] ; do
		cp_y=0
		while [ "$cp_y" -lt "$T_SZ" ] ; do
			eval 'tetroni_'${cp_x}_$cp_y'=$tetroni_'$1_${cp_x}_$cp_y
			cp_y=$(($cp_y + 1))
		done
		cp_x=$(($cp_x + 1))
	done
}
newTetroni() {
	copyTetroni "$next"
	next=`getRandTetroni`
	Tx=$(($W / 2 - 2))
	Ty=0
	if inBounds ; then :
	else
		display
		echo 'game over'
		exit
	fi
}

render() {
	rY=$Ty
	bringDown
	By=$Ty
	Ty=$rY

	w=`tput cols`
	h=`tput lines`
	unset lines
	rY=0
	while [ "$rY" -lt "$H" ] ; do
		line=$WALL
		rX=0
		while [ "$rX" -lt "$W" ] ; do
			eval 'rV=$GRID_'${rX}_$rY
			rDx=$(($rX - $Tx))
			rDy=$(($rY - $Ty))
			bdy=$(($rY - $By))
			if [ 0 -le "$rDx" ] && [ "$rDx" -lt "$T_SZ" ] && [ 0 -le "$rDy" ] && [ "$rDy" -lt "$T_SZ" ] && eval '[ "$tetroni_'${rDx}_$rDy'" != "" ]' ; then
				eval 'rV=$FALLING$tetroni_'${rDx}_$rDy
				rP=$BIT
			elif [ 0 -le "$rDx" ] && [ "$rDx" -lt "$T_SZ" ] && [ 0 -le "$bdy" ] && [ "$bdy" -lt "$T_SZ" ] && eval '[ "$tetroni_'${rDx}_$bdy'" != "" ]' ; then
				rV=$GHOST
				rP=$BIT
			else
				if [ "$rV" = "" ] ; then
					rP=$VOID
				else
					rP=$BIT
				fi
			fi
			if [ "$paused" = 1 ] ; then
				rV=
			fi
			line=$line$rV$rP$CLEAR
		rX=$(($rX + 1))
		done
		line=$line$WALL
		if [ "$rY" -lt "$T_SZ" ] ; then
			rX=0
			while [ "$rX" -lt "$T_SZ" ] ; do
				eval 'rV=$tetroni_'"${next}_${rX}_$rY"
				if [ "$rV" = "" ] ; then
					rP=$VOID
				else
					rP=$BIT
				fi
				if [ "$paused" = 1 ] ; then
					rV=
				fi
				line=$line$PREVIEW$rV$rP$CLEAR
			rX=$(($rX + 1))
			done
		fi
		lines=$lines$line$ENDL
	rY=$(($rY + 1))
	done
	line=$L_
	rX=0
	while [ "$rX" -lt "$W" ] ; do
		line=$line$BOT
		rX=$(($rX + 1))
	done
	lines=$lines$line$_J
}
draw() {
	showed=0
	IFS_PREV=$IFS
	IFS=$ENDL
	start=$(( ( $w - $W * $CW ) / 2 ))
	for l in $lines ; do
		if [ "$showed" = 0 ] ; then
			printf %"$start"d "$score"00
			showed=1
		else
			printf %"$start"s ''
		fi
		printf '%s\n' "$l"
	done
	IFS=$IFS_PREV
}
display() {
	render
	tput cuu $(($H + 1))
	draw
}
fall() {
	if slide 0 1 ; then :
	else
		land
	fi
}
land() {
	lDx=0
	while [ "$lDx" -lt "$T_SZ" ] ; do
		lDy=0
		while [ "$lDy" -lt "$T_SZ" ] ; do
			lX=$(($lDx + $Tx))
			lY=$(($lDy + $Ty))
			eval 'v=$tetroni_'${lDx}_$lDy
			if [ "$v" != '' ] ; then
				#GRID[lX+lY*W]=$v
				eval "GRID_${lX}_$lY="'$v'
			fi
			lDy=$(($lDy + 1))
		done
		lDx=$(($lDx + 1))
	done
	newTetroni
	checkMatch
}
checkMatch() {
	matches=0
	cmS=1
	cmDy=$(($H - 1))
	cmY=$cmDy
	while [ "$cmY" -ge 0 ] ; do
		rowMatch=1
		cmX=0
		while [ "$cmX" -lt "$W" ] ; do
			if [ "$cmY" != "$cmDy" ] ; then
				eval "GRID_${cmX}_$cmDy="'$GRID_'"${cmX}_$cmY"
				eval "GRID_${cmX}_$cmY="
			fi
			if eval '[ "$GRID_'${cmX}_$cmDy'" = "" ]' ; then
				rowMatch=0
			fi
			cmX=$(($cmX + 1))
		done
		if [ "$rowMatch" -ne 1 ] ; then
			cmDy=$(($cmDy - 1))
		else
			matches=$(($matches + 1))
		fi
		cmY=$(($cmY - 1))
	done
	if [ "$matches" -ne 0 ] ; then
		while [ "$matches" -gt 1 ] ; do
			cmS=$(($cmS * 2))
			matches=$(($matches - 1))
		done
		score=$(($score + $cmS))
	fi
}
inBounds() {
	bDx=0
	while [ "$bDx" -lt "$T_SZ" ] ; do
		bDy=0
		while [ "$bDy" -lt "$T_SZ" ] ; do
			bX=$(($bDx + $Tx))
			bY=$(($bDy + $Ty))
			eval 'bV=$tetroni_'${bDx}_$bDy
			if [ "$bV" != '' ] ; then
				if [ "$bX" -lt 0 ] || [ "$bX" -ge "$W" ] || [ "$bY" -lt 0 ] || [ "$bY" -ge "$H" ] || eval '[ "$GRID_'${bX}_$bY'" != "" ]' ; then
					return 1
				fi
			fi
			bDy=$(($bDy + 1))
		done
		bDx=$(($bDx + 1))
	done
	return 0
}
slide() {
	Tx=$(($Tx + $1))
	Ty=$(($Ty + $2))
	if inBounds ; then :
	else
		Tx=$(($Tx - $1))
		Ty=$(($Ty - $2))
		return 1
	fi
	return 0
}
bringDown() {
	while slide 0 1 ; do
		:
	done
}
rotate() {
	forceRotate $1
	if inBounds ; then :
	else
		thrash || forceRotate $((0 - $1))
	fi
}
thrash() {
	oldTx=$Tx
	oldTy=$Ty

	for thrashDx in -1 0 1 ; do
		for thrashDy in 0 1 ; do
			Tx=$(($oldTx + $thrashDx))
			Ty=$(($oldTy + $thrashDy))
			inBounds && return 0
		done
	done

	Tx=$oldTx
	Ty=$oldTy
	return 1
}
forceRotate() {
	csz=$T_SZ
	s=$(($csz - 1))
	half=$(( ( $csz + 1 ) / 2))
	hsz=$(($csz / 2))
	x=0
	while [ "$x" -lt "$half" ] ; do
		y=0
		while [ "$y" -lt "$hsz" ] ; do
			eval 'val=$tetroni_'${x}_$y
			for i in 0 1 2 3 ; do
				if [ "$1" -ge 1 ] ; then
					oy=$y
					y=$x
					x=$(($s - $oy))
				else
					ox=$x
					x=$y
					y=$(($s - $ox))
				fi
				eval 'pval=$tetroni_'${x}_$y
				eval 'tetroni_'${x}_$y'=$val'
				val=$pval
			done
			y=$(($y + 1))
		done
		x=$(($x + 1))
	done
}
togglePause() {
	if [ "$paused" = 0 ] ; then
		paused=1
		obit=$BIT
		BIT=$VOID
		display
		BIT=$obit
	else
		paused=0
		display
	fi
}
next=`getRandTetroni`
newTetroni
render
draw
IFS=
(
	while sleep .5 ; do
		printf j
		#printf $'\a' >&2
	done &
	while read_ch p; do 
		if [ "$p" = '' ] ; then
			read_ch ap
			p=$p$ap
			read_ch ap
			p=$p$ap
		fi
		case "$p" in
		h|"$LEFT")
			printf h
		;;
		j|"$DOWN")
			printf j
		;;
		k|x|"$UP"|"$C_RIGHT")
			printf k
		;;
		r|z|"$C_UP"|"$C_LEFT")
			printf r
		;;
		l|$RIGHT)
			printf l
		;;
		' '|"$C_DOWN")
			printf G
		;;
		p)
			printf p
		;;
		esac
	done 
) | while read_ch p; do
	#assume that if the delay was less than 100 ms we
	#read input from buffer and therefore need to 
	#frameskip
	skip=0
	#if ((`date +%s%3N` - date < MIN_BUFF_WAIT)) ; then
	#	skip=1
	#else
	#	skip=0
	#fi
	if [ "$paused" = 1 ] ; then
		if [ "$p" = p ] ; then
			togglePause
		fi
	else
		case "$p" in
		h)
			slide -1 0
		;;
		j)
			fall
		;;
		k)
			rotate 1
		;;
		l)
			slide 1 0
		;;
		G)
			bringDown
			land
		;;
		r)
			rotate -1
		;;
		p)
			togglePause
		;;
		esac
	fi
	if [ "$skip" = 1 ] && [ "$fs" -lt "$MAX_FRAMESKIP" ] ; then
		fs=$(($fs + 1))
	else
		if [ "$paused" = 0 ] ; then
			display
		fi
		fs=0
	fi
	date=`date +%s%3N`
done
